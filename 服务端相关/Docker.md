**Docker：**应用容器引擎

**镜像Image：**开发者将应用及其所有依赖（第三方库、配置文件、运行时）打包得到的一个标准化单元，是一个只读的静态模版，相当于一个安装包

**容器Container：**镜像运行起来的实例（镜像类似于类Class，容器就是这个类的一个对象object）。容器启动后，就在一个隔离的环境中运行，有自己的文件系统、网络空间、进程空间，表现得就像一个独立的虚拟机、操作系统、计算机一样。

**仓库Repository：**存在镜像的地方，类似github

**Dockerfile：**一个文本文件，包含了一系列的指令，用来告诉Docker如何一步步自动构建一个镜像。例如：基于那个基础镜像，复制哪些文件进去、安装什么依赖、容器启动时默认执行的命令是什么等等

> Dockerfile构建成镜像，镜像运行成容器

**宿主机：**运行容器的计算机

**数据卷Volume：**容器是无状态的，即容器被删除后，里面产生的数据也消失了。数据卷是用来持久化存储数据的，可以让数据独立于容器的生命周期存在，即使容器被删除了，数据卷中的数据依然保留，同时可用于容器之间共享数据（例如一个mysql的容器被删除后，如果没有数据卷那么数据库中的数据就丢失了）

**网络：**Docker运行容器之间、容器与宿主机（本机）、容器与外部网络之间通信，有多种网络模式（桥接模式、主机模式）来满足不同场景的需求

# 命令

```bash
# 拉取镜像
docker pull xxx
# 查看已下载的镜像
docker images
# 删除镜像
docker rmi 镜像名 

# 查看正在运行的容器
docker ps
# 基于xx镜像创建并运行容器
docker run -d -p 宿主机端口:容器端口 -v 宿主机文件夹:容器文件夹 --name 容器名 基于的镜像名
-d容器在后台运行，而不是占用当前终端
-p设置宿主机与容器的端口映射
-v将宿主机与容器的文件目录绑定，容器内对该文件的修改会影响宿主机的对应文件，宿主机对文件的修改同样会影响容器内对应的文件
# 停止已经运行的容器
docker stop 容器名
# 删除容器
docker rm 容器名

# 进入容器内部，获取一个交互式终端进行命令调试
docker exec -it 容器名 /bin/sh
```

# Dockerfile配置

```dockerfile
# 获取基础镜像，我们的镜像基于该基础镜像进行构建
FROM XXX
# 切换到镜像内的一个目录，后面的命令都是基于该目录执行的，相当于镜像运行起来的容器的工作区
WORKDIR XXX
# 将当前目录内容复制到容器内的/app目录
COPY . .
# 镜像内运行终端命令，安装依赖
RUN pip install -r requirements.txt
# 镜像对外提供服务的端口
EXPOSE 8000
# 容器运行的命令（每当容器启动的时候，容器内部会自动执行这个命令，一个dockerfile文件只能有一个cmd）
CMD ["python", "main.py"]
```

构建镜像

```bash
# 在当前文件夹下基于Dockerfile文件构建镜像
docker build -t 镜像名 .
```



# docker compose

轻量级容器编排技术

场景：一个应用有前端、后端、数据库。如果将三者都构建成一个镜像，运行到一个容器中，那么当其中一个故障时另外两个都瘫痪；而如果将三者分别构建成三个镜像，然后运行成三个容器，会需要配置它们之间的网络，十分繁琐。

使用docker compose编写一个`docker-compose.yaml`文件，将三个服务的运行容器的命令写到一个yaml文件中，docker compose直接为三个服务创建三个容器，并将他们放入到一个网络中



# Kubernetes

企业级服务器集群，大规模容器编排技术

