# Reactive的原理

Reactive直接利用Proxy，由于Proxy只能代理对象，所以Reactive只能将对象变为响应式，不能将基本数据类型变为响应式

```js
const raw={count:0};
const state=new Proxy(raw,{
  get(target,key){
    // 收集依赖
    track(target,key)
    return target[key]
  },
  set(target,key,value){
    // 修改值
    target[key]=value
    // 触发更新
    trigger(target,key)
    return true;
  }
})
```

# Ref的原理

Ref就是一个包装对象，利用类属性的getter与setter拦截对.value的访问，从而实现响应式

```js
class RefImpl{
  constructor(value){
    this._value=value
  }
  get value(){
    // 收集依赖
    track(this,'value')
    return this._value
  }
  set value(newValue){
    // 触发更新
    if(newVlaue!==this._value){
      this._value=newValue
      trigger(this,'value')
    }
  }
}
```





